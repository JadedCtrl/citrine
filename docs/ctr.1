
." Manpage for ctr.
.TH man 1 "1 June 2017" "1.0" "CTR man page"
.SH NAME
ctr - run a Citrine program
.SH SYNOPSIS
ctr [PROGRAM]
.SH DESCRIPTION
Citrine*R is general purpose programming language for UNIX*R-like operating systems.
.SH REFERENCE MANUAL
Citrine has 5 literals:
.RS 4
.br 
- Nil
.br
- Booleans (True, False)
.br
- Numbers (1, -2, 3.5)
.br
- Strings 'All Strings are UTF8!'
.br
- Code Blocks { parameters code }
.br

.RE
The following messages are part of the Core API of the Citrine Programming Language:
.br
.BR.BR.BR

.B Nil
.nf
.fi
.BR.BR.BR

.B [Nil] Nil?
.nf
.fi
.BR.BR.BR

.B [Nil] string
.nf
.fi
.BR.BR.BR

.B [Nil] number
.nf
.fi
.BR.BR.BR

.B [Nil] boolean
.nf
.fi
.BR.BR.BR

.B Object
.nf
.fi
.BR.BR.BR

.B [Object] type
.nf
.fi
.BR.BR.BR

.B [Object] toString
.nf
.fi
.BR.BR.BR

.B [Object] toNumber
.nf
.fi
.BR.BR.BR

.B [Object] toBoolean
.nf
.fi
.BR.BR.BR

.B [Object] equals: [other]
.nf
.fi
.BR.BR.BR

.B [Object] myself
.nf
.fi
.BR.BR.BR

.B [Object] learn: [String] means: [String].
.nf
.fi
.BR.BR.BR

.B [Object] do
.nf
.fi
.BR.BR.BR

.B [Object] done
.nf
.fi
.BR.BR.BR

.B [Object] copy
.nf
.fi
.BR.BR.BR

.B [Object] case: [Object] do: [Block].
.nf
.fi
.BR.BR.BR

.B [Object] message: [String] arguments: [Array]
.nf
.fi
.BR.BR.BR

.B [Object] on: [String] do: [Block]
.nf
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B [Object] respond: [String]
.nf
.fi
.BR.BR.BR

.B [Object] Nil?
.nf
.fi
.BR.BR.BR

.B Boolean
.nf
.fi
.BR.BR.BR

.B [Boolean] = [other]
.nf
.fi
.BR.BR.BR

.B [Boolean] != [other]
.nf
.fi
.BR.BR.BR

.B [Boolean] toString
.nf
.fi
.BR.BR.BR

.B [Boolean] break
.nf
.fi
.BR.BR.BR

.B [Boolean] continue
.nf
.fi
.BR.BR.BR

.B [Boolean] true: [block]
.nf
.fi
.BR.BR.BR

.B [Boolean] false: [block]
.nf
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B [Boolean] not
.nf
.fi
.BR.BR.BR

.B [Boolean] either: [this] or: [that]
.nf
.fi
.BR.BR.BR

.B [Boolean] & [other]
.nf
.fi
.BR.BR.BR

.B [Boolean] ! [other]
.nf
.fi
.BR.BR.BR

.B [Boolean] | [other]
.nf
.fi
.BR.BR.BR

.B [Boolean] ? [other]
.nf
.fi
.BR.BR.BR

.B [Boolean] toNumber
.nf
.fi
.BR.BR.BR

.B Number
.nf
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B [Number] > [other]
.nf
.fi
.BR.BR.BR

.B [Number] >=: [other]
.nf
.fi
.BR.BR.BR

.B [Number] < [other]
.nf
.fi
.BR.BR.BR

.B [Number] <=: [other]
.nf
.fi
.BR.BR.BR

.B [Number] = [other]
.nf
.fi
.BR.BR.BR

.B [Number] !=: [other]
.nf
.fi
.BR.BR.BR

.B [Number] between: [low] and: [high]
.nf
.fi
.BR.BR.BR

.B [Number] odd
.nf
.fi
.BR.BR.BR

.B [Number] even
.nf
.fi
.BR.BR.BR

.B [Number] + [Number]
.nf
.fi
.BR.BR.BR

.B [Number] +=: [Number]
.nf
.fi
.BR.BR.BR

.B [Number] - [Number]
.nf
.fi
.BR.BR.BR

.B [Number] -=: [number]
.nf
.fi
.BR.BR.BR

.B [Number] * [Number or Block]
.nf
.fi
.BR.BR.BR

.B [Block] * [Number]
.nf
.fi
.BR.BR.BR

.B [Number] *=: [Number]
.nf
.fi
.BR.BR.BR

.B [Number] / [Number]
.nf
.fi
.BR.BR.BR

.B [Number] /=: [Number]
.nf
.fi
.BR.BR.BR

.B [Number] % [modulo]
.nf
.fi
.BR.BR.BR

.B [Number] power: [power]
.nf
.fi
.BR.BR.BR

.B [Number] random
.nf
.fi
.BR.BR.BR

.B [Number] pos
.nf
.fi
.BR.BR.BR

.B [Number] neg
.nf
.fi
.BR.BR.BR

.B [Number] max: [other]
.nf
.fi
.BR.BR.BR

.B [Number] min: [other]
.nf
.fi
.BR.BR.BR

.B [Number] factorial
.nf
.fi
.BR.BR.BR

.B [Number] floor
.nf
.fi
.BR.BR.BR

.B [Number] qualify: 'meters'.
.nf
.fi
.BR.BR.BR

.B [Number] [String]
.nf
.fi
.BR.BR.BR

.B [Number] qualification.
.nf
.fi
.BR.BR.BR

.BR.BR.BR

.B [Number] ceil
.nf
.fi
.BR.BR.BR

.B [Number] round
.nf
.fi
.BR.BR.BR

.B [Number] abs
.nf
.fi
.BR.BR.BR

.B [Number] sqrt
.nf
.fi
.BR.BR.BR

.B [Number] exp
.nf
.fi
.BR.BR.BR

.B [Number] sin
.nf
.fi
.BR.BR.BR

.B [Number] cos
.nf
.fi
.BR.BR.BR

.B [Number] tan
.nf
.fi
.BR.BR.BR

.B [Number] atan
.nf
.fi
.BR.BR.BR

.B [Number] log
.nf
.fi
.BR.BR.BR

.B [Number] byte
.nf
.fi
.BR.BR.BR

.B [Number] toString
.nf
.fi
.BR.BR.BR

.B [Number] boolean
.nf
.fi
.BR.BR.BR

.B String
.nf
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B [String] bytes
.nf
.fi
.BR.BR.BR

.B [String] = [other]
.nf
.fi
.BR.BR.BR

.B [String] != [other]
.nf
.fi
.BR.BR.BR

.B [String] length
.nf
.fi
.BR.BR.BR

.B [String] + [other]
.nf
.fi
.BR.BR.BR

.B [String] append: [String].
.nf
.fi
.BR.BR.BR

.B [String] from: [position] to: [destination]
.nf
.fi
.BR.BR.BR

.B [String] from: [start] length: [length]
.nf
.fi
.BR.BR.BR

.B [String] skip: [number]
.nf
.fi
.BR.BR.BR

.B [String] at: [position]
.nf
.fi
.BR.BR.BR

.B [String] byte: [position]
.nf
.fi
.BR.BR.BR

.B [String] first: [subject]
.nf
.fi
.BR.BR.BR

.B [String] uppercase
.nf
.fi
.BR.BR.BR

.B [String] lowercase
.nf
.fi
.BR.BR.BR

.B [String] last: [subject]
.nf
.fi
.BR.BR.BR

.B [String] [key]: [value]
.nf
.fi
.BR.BR.BR

.B [String] replace: [string] with: [other]
.nf
.fi
.BR.BR.BR

.B [String] pattern: [String] do: [Block] options: [String].
.nf
.fi
.BR.BR.BR

.B [String] pattern: [String] do: [Block].
.nf
.fi
.BR.BR.BR

.B [String] contains: [String]
.nf
.fi
.BR.BR.BR

.B [String] matches: [String].
.nf
.fi
.BR.BR.BR

.B [String] trim
.nf
.fi
.BR.BR.BR

.B [String] toNumber
.nf
.fi
.BR.BR.BR

.B [String] toBoolean
.nf
.fi
.BR.BR.BR

.B [String] split: [String]
.nf
.fi
.BR.BR.BR

.B [String] characters.
.nf
.fi
.BR.BR.BR

.B [String] list
.nf
.fi
.BR.BR.BR

.B [String] append byte: [Number].
.nf
.fi
.BR.BR.BR

.B [String] compare: [String]
.nf
.fi
.BR.BR.BR

.B [String] < [String]
.nf
.fi
.BR.BR.BR

.B [String] ≤ [String]
.nf
.fi
.BR.BR.BR

.B [String] > [String]
.nf
.fi
.BR.BR.BR

.B [String] ≥ [String]
.nf
.fi
.BR.BR.BR

.B [String] escape: '\n'.
.nf
.fi
.BR.BR.BR

.B [String] escapeQuotes.
.nf
.fi
.BR.BR.BR

.B [String] unescape: '\n'.
.nf
.fi
.BR.BR.BR

.B [String] html
.nf
.fi
.BR.BR.BR

.B [String] hashWithKey: [String]
.nf
.fi
.BR.BR.BR

.B [String] eval
.nf
.fi
.BR.BR.BR

.B Block
.nf
.fi
.BR.BR.BR

.B [Block] apply: [object]
.nf
.fi
.BR.BR.BR

.B [Block] whileTrue: [block]
.nf
.fi
.BR.BR.BR

.B [Block] whileFalse: [block]
.nf
.fi
.BR.BR.BR

.B [Block] run
.nf
.fi
.BR.BR.BR

.B [Block] set: [name] value: [object]
.nf
.fi
.BR.BR.BR

.B [Block] error: [object].
.nf
.fi
.BR.BR.BR

.B [Block] catch: [otherBlock]
.nf
.fi
.BR.BR.BR

.B [Block] toString
.nf
.fi
.BR.BR.BR

.B [List] new
.nf
.fi
.BR.BR.BR

.B [Array] new
.nf
.fi
.BR.BR.BR

.B [Array] type
.nf
.fi
.BR.BR.BR

.B [Array] add: [Element].
.nf
.fi
.BR.BR.BR

.B [Array] push: [Element]
.nf
.fi
.BR.BR.BR

.B [Array] min
.nf
.fi
.BR.BR.BR

.B [Array] max
.nf
.fi
.BR.BR.BR

.B [Array] sum
.nf
.fi
.BR.BR.BR

.B [Array] product
.nf
.fi
.BR.BR.BR

.B [Array] map: [Block].
.nf
.fi
.BR.BR.BR

.B [Array] each: [Block].
.nf
.fi
.BR.BR.BR

.B [Array] ← [Element1] ; [Element2] ; ...
.nf
.fi
.BR.BR.BR

.B [Array] unshift: [Element].
.nf
.fi
.BR.BR.BR

.B [Array] join: [Glue].
.nf
.fi
.BR.BR.BR

.B [Array] at: [Index]
.nf
.fi
.BR.BR.BR

.B [Array] first.
.nf
.fi
.BR.BR.BR

.B [Array] last.
.nf
.fi
.BR.BR.BR

.B [Array] secondLast.
.nf
.fi
.BR.BR.BR

.B [Array] @ [Index]
.nf
.fi
.BR.BR.BR

.B [Array] put: [Element] at: [Index]
.nf
.fi
.BR.BR.BR

.B [Array] pop
.nf
.fi
.BR.BR.BR

.B [Array] - [Number]
.nf
.fi
.BR.BR.BR

.B [Array] shift
.nf
.fi
.BR.BR.BR

.B [Array] count
.nf
.fi
.BR.BR.BR

.B [Array] from: [Begin] length: [End]
.nf
.fi
.BR.BR.BR

.B [Array] replace: [Number] length: [Number] with: [Array].
.nf
.fi
.BR.BR.BR

.B [Array] + [Array]
.nf
.fi
.BR.BR.BR

.B [Array] by: [Array].
.nf
.fi
.BR.BR.BR

.B [Array] copy
.nf
.fi
.BR.BR.BR

.BR.BR.BR

.B [Array] sort: [Block]
.nf
.fi
.BR.BR.BR

.B [Array] toString
.nf
.fi
.BR.BR.BR

.B [Array] fill: [Number] with: [Object]
.nf
.fi
.BR.BR.BR

.B [Array] column: [Number]
.nf
.fi
.BR.BR.BR

.B [Array] indexOf: [Object].
.nf
.fi
.BR.BR.BR

.B [Array] serialize
.nf
.fi
.BR.BR.BR

.B Map
.nf
.fi
.BR.BR.BR

.B [Map] type
.nf
.fi
.BR.BR.BR

.B [Map] put: [Element] at: [Key]
.nf
.fi
.BR.BR.BR

.B [Map] [Key]: [Value]
.nf
.fi
.BR.BR.BR

.B [Map] - [String]
.nf
.fi
.BR.BR.BR

.B [Map] keys
.nf
.fi
.BR.BR.BR

.B [Map] values
.nf
.fi
.BR.BR.BR

.B [Map] at: [Key]
.nf
.fi
.BR.BR.BR

.B [Map] @ [Key]
.nf
.fi
.BR.BR.BR

.B [Map] count
.nf
.fi
.BR.BR.BR

.B [Map] each: [Block]
.nf
.fi
.BR.BR.BR

.B [Map] has: [Object]
.nf
.fi
.BR.BR.BR

.B [Map] toString
.nf
.fi
.BR.BR.BR

.B [Map] serialize
.nf
.fi
.BR.BR.BR

.B File
.nf
.fi
.BR.BR.BR

.B [File] path
.nf
.fi
.BR.BR.BR

.B [File] toString
.nf
.fi
.BR.BR.BR

.B [File] read
.nf
.fi
.BR.BR.BR

.B [File] write: [String]
.nf
.fi
.BR.BR.BR

.B [File] append: [String]
.nf
.fi
.BR.BR.BR

.B [File] exists
.nf
.fi
.BR.BR.BR

.B [File] include
.nf
.fi
.BR.BR.BR

.B [File] delete
.nf
.fi
.BR.BR.BR

.B [File] size
.nf
.fi
.BR.BR.BR

.B [File] open: [string]
.nf
.fi
.BR.BR.BR

.B [File] close.
.nf
.fi
.BR.BR.BR

.B [File] readBytes: [Number].
.nf
.fi
.BR.BR.BR

.B [File] writeBytes: [String].
.nf
.fi
.BR.BR.BR

.B [File] seek: [Number].
.nf
.fi
.BR.BR.BR

.B [File] rewind.
.nf
.fi
.BR.BR.BR

.B [File] end.
.nf
.fi
.BR.BR.BR

.BR.BR.BR

.B [File] unlock.
.nf
.fi
.BR.BR.BR

.B [File] lock.
.nf
.fi
.BR.BR.BR

.B [File] list: [String].
.nf
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B Program
.nf
.fi
.BR.BR.BR

.B [Program] dust
.nf
.fi
.BR.BR.BR

.B [Program] objectCount
.nf
.fi
.BR.BR.BR

.B [Program] kept
.nf
.fi
.BR.BR.BR

.B [Program] allocated
.nf
.fi
.BR.BR.BR

.B [Program] stuck
.nf
.fi
.BR.BR.BR

.B [Program] memoryLimit
.nf
.fi
.BR.BR.BR

.B [Program] tidiness: [Number]
.nf
.fi
.BR.BR.BR

.B [Program] toString.
.nf
.fi
.BR.BR.BR

.B [Program] number.
.nf
.fi
.BR.BR.BR

.B [Program] shell: [String]
.nf
.fi
.BR.BR.BR

.B [Program] argument: [Number]
.nf
.fi
.BR.BR.BR

.B [Program] argCount
.nf
.fi
.BR.BR.BR

.B [Program] exit
.nf
.fi
.BR.BR.BR

.B [Program] env: [String]
.nf
.fi
.BR.BR.BR

.B [Program] env: [Key] val: [Value]
.nf
.fi
.BR.BR.BR

.B [Program] waitForInput
.nf
.fi
.BR.BR.BR

.B [Program] input.
.nf
.fi
.BR.BR.BR

.B [Program] flush.
.nf
.fi
.BR.BR.BR

.B [Program] pid
.nf
.fi
.BR.BR.BR

.B [Program] toString
.nf
.fi
.BR.BR.BR

.B [Program] number
.nf
.fi
.BR.BR.BR

.B [Program] error: [String]
.nf
.fi
.BR.BR.BR

.B [Clock] wait: [Number]
.nf
.fi
.BR.BR.BR

.B [Clock] new: [Number]
.nf
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B [Clock] like: [Clock]
.nf
.fi
.BR.BR.BR

.B [Clock] zone: [String]
.nf
.fi
.BR.BR.BR

.B [Clock] zone
.nf
.fi
.BR.BR.BR

.B [Clock] zone: [Number]
.nf
.fi
.BR.BR.BR

.B [Clock] zone: [Number]
.nf
.fi
.BR.BR.BR

.B [Clock] zone: [Number]
.nf
.fi
.BR.BR.BR

.B [Clock] zone: [Number]
.nf
.fi
.BR.BR.BR

.B [Clock] zone: [Number]
.nf
.fi
.BR.BR.BR

.B [Clock] zone: [Number]
.nf
.fi
.BR.BR.BR

.B [Clock] year
.nf
.fi
.BR.BR.BR

.B [Clock] month
.nf
.fi
.BR.BR.BR

.B [Clock] day
.nf
.fi
.BR.BR.BR

.B [Clock] hour
.nf
.fi
.BR.BR.BR

.B [Clock] minute
.nf
.fi
.BR.BR.BR

.B [Clock] second
.nf
.fi
.BR.BR.BR

.B [Clock] yearday
.nf
.fi
.BR.BR.BR

.B [Clock] weekday
.nf
.fi
.BR.BR.BR

.B [Clock] time.
.nf
.fi
.BR.BR.BR

.B [Clock] week
.nf
.fi
.BR.BR.BR

.B [Clock] format: [String]
.nf
.fi
.BR.BR.BR

.B [Clock] toString
.nf
.fi
.BR.BR.BR

.B [Clock] number
.nf
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B [Clock] add: [Number].
.nf
.fi
.BR.BR.BR

.B [Clock] subtract: [Number].
.nf
.fi
.BR.BR.BR

.B [Clock] new
.nf
.fi
.BR.BR.BR

.B [Pen] write: [String]
.nf
.fi
.BR.BR.BR

.B [Pen] brk
.nf
.fi
.BR.BR.BR

.B [Pen] tab
.nf
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B Request get: [string]
.nf
.fi
.BR.BR.BR

.B Request getArray: [string].
.nf
.fi
.BR.BR.BR

.B Request post: [string].
.nf
.fi
.BR.BR.BR

.B Request postArray: [string].
.nf
.fi
.BR.BR.BR

.B Request cookie: [string].
.nf
.fi
.BR.BR.BR

.B Request cookieArray: [string].
.nf
.fi
.BR.BR.BR

.B Request file: [string].
.nf
.fi
.BR.BR.BR

.B Request serverOption: [string] is: [string].
.nf
.fi
.BR.BR.BR

.B Request host: [string] listen: [string] pid: [string] callback: [block].
.nf
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B Curl new.
.nf
.fi
.BR.BR.BR

.B [Curl] cleanup.
.nf
.fi
.BR.BR.BR

.B [Curl] type.
.nf
.fi
.BR.BR.BR

.B [Curl] respondTo: [string] with: [Object]
.nf
.fi
.BR.BR.BR

.B [Curl] perform.
.nf
.fi
.BR.BR.BR

.BR.BR.BR

.B [Json] new
.nf
.fi
.BR.BR.BR

.BR.BR.BR

.B [Json] parse: [String].
.nf
.fi
.BR.BR.BR

.B [Json] jsonify: [Map].
.nf
.fi
.BR.BR.BR

.B C-constructor function.
.nf
.fi
.BR.BR.BR

.B [Pg] new: [String].
.nf
.fi
.BR.BR.BR

.B [Pg] query: [String] parameters: [Array].
.nf
.fi
.BR.BR.BR

.B [Pg] close.
.nf
.fi

.SH BUGS
This is a preliminary version (< 1.0) of Citrine, there might still be very serious bugs.
Please refrain from using this version in a production environment. This version of Citrine
is still considered 'alpha' stage and cannot be expected to be reliable.

.SH AUTHOR
Gabor de Mooij and the Citrine Community
