
." Manpage for ctr.
.TH man 1 "1 June 2017" "1.0" "CTR man page"
.SH NAME
ctr - run a Citrine program
.SH SYNOPSIS
ctr [PROGRAM]
.SH DESCRIPTION
Citrine is general purpose programming language for UNIX-like operating systems.
.SH REFERENCE MANUAL
Citrine has 5 literals:
.RS 4
.br 
- Nil
.br
- Booleans (True, False)
.br
- Numbers (1, -2, 3.5)
.br
- Strings 'All Strings are UTF8!'
.br
- Code Blocks { parameters code }
.br

.RE
The following messages are part of the Core API of the Citrine Programming Language:
.br
.BR.BR.BR

.B  * Nil
.nf
    
.fi
.BR.BR.BR

.B  * [Nil] Nil?
.nf
    
.fi
.BR.BR.BR

.B  * [Nil] string
.nf
    
.fi
.BR.BR.BR

.B  * [Nil] number
.nf
    
.fi
.BR.BR.BR

.B  * [Nil] boolean
.nf
    
.fi
.BR.BR.BR

.B  * Object
.nf
    
.fi
.BR.BR.BR

.B  * [Object] type
.nf
    
.fi
.BR.BR.BR

.B  * [Object] string
.nf
    
.fi
.BR.BR.BR

.B  * [Object] number
.nf
    
.fi
.BR.BR.BR

.B  * [Object] boolean
.nf
    
.fi
.BR.BR.BR

.B  * [Object] equals: [other]
.nf
    
.fi
.BR.BR.BR

.B  * [Object] myself
.nf
    
.fi
.BR.BR.BR

.B  * [Object] do
.nf
    
.fi
.BR.BR.BR

.B  * [Object] done
.nf
    
.fi
.BR.BR.BR

.B  * [Object] copy
.nf
    
.fi
.BR.BR.BR

.B  * [Object] case: [Object] do: [Block].
.nf
    
.fi
.BR.BR.BR

.B  * [Object] message: [String] arguments: [List]
.nf
    
.fi
.BR.BR.BR

.B  * [Object] on: [String] do: [Block]
.nf
    
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B  * [Object] respond: [String]
.nf
    
.fi
.BR.BR.BR

.B  * [Object] Nil?
.nf
    
.fi
.BR.BR.BR

.B  * [Object] learn: [String] means: [String].
.nf
    
.fi
.BR.BR.BR

.B  * Boolean
.nf
    
.fi
.BR.BR.BR

.B  * [Boolean] = [other]
.nf
    
.fi
.BR.BR.BR

.B  * [Boolean] != [other]
.nf
    
.fi
.BR.BR.BR

.B  * [Boolean] string
.nf
    
.fi
.BR.BR.BR

.B  * [Boolean] break
.nf
    
.fi
.BR.BR.BR

.B  * [Boolean] continue
.nf
    
.fi
.BR.BR.BR

.B  * [Boolean] true: [block]
.nf
    
.fi
.BR.BR.BR

.B  * [Boolean] false: [block]
.nf
    
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B  * [Boolean] not
.nf
    
.fi
.BR.BR.BR

.B  * [Boolean] either: [this] or: [that]
.nf
    
.fi
.BR.BR.BR

.B  * [Boolean] and: [other]
.nf
    
.fi
.BR.BR.BR

.B  * [Boolean] nor: [other]
.nf
    
.fi
.BR.BR.BR

.B  * [Boolean] or: [other]
.nf
    
.fi
.BR.BR.BR

.B  * [Boolean] ? [other]
.nf
    
.fi
.BR.BR.BR

.B  * [Boolean] number
.nf
    
.fi
.BR.BR.BR

.B  * Number
.nf
    
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B  * [Number] > [other]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] ≥ [other]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] < [other]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] ≤ [other]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] = [other]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] ≠ [other]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] between: [Number] and: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] odd?
.nf
    
.fi
.BR.BR.BR

.B  * [Number] even?
.nf
    
.fi
.BR.BR.BR

.B  * [Number] + [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] add: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] - [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] subtract: [number]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] * [Number or Block]
.nf
    
.fi
.BR.BR.BR

.B  * [Block] * [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] multiply by: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] / [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] devide by: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] % [modulo]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] power: [power]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] positive?
.nf
    
.fi
.BR.BR.BR

.B  * [Number] negative?
.nf
    
.fi
.BR.BR.BR

.B  * [Number] floor
.nf
    
.fi
.BR.BR.BR

.B  * [Number] qualify: 'meters'.
.nf
    
.fi
.BR.BR.BR

.B  * [Number] [String]
.nf
    
.fi
.BR.BR.BR

.B  * [Number] qualification.
.nf
    
.fi
.BR.BR.BR

.BR.BR.BR

.B  * [Number] ceil
.nf
    
.fi
.BR.BR.BR

.B  * [Number] round
.nf
    
.fi
.BR.BR.BR

.B  * [Number] absolute
.nf
    
.fi
.BR.BR.BR

.B  * [Number] square root
.nf
    
.fi
.BR.BR.BR

.B  * [Number] byte
.nf
    
.fi
.BR.BR.BR

.B  * [Number] string
.nf
    
.fi
.BR.BR.BR

.B  * [Number] boolean
.nf
    
.fi
.BR.BR.BR

.B  * String
.nf
    
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B  * [String] bytes
.nf
    
.fi
.BR.BR.BR

.B  * [String] = [other]
.nf
    
.fi
.BR.BR.BR

.B  * [String] ≠ [other]
.nf
    
.fi
.BR.BR.BR

.B  * [String] length
.nf
    
.fi
.BR.BR.BR

.B  * [String] + [other]
.nf
    
.fi
.BR.BR.BR

.B  * [String] append: [String].
.nf
    
.fi
.BR.BR.BR

.B  * [String] from: [start] length: [length]
.nf
    
.fi
.BR.BR.BR

.B  * [String] offset: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [String] character: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [String] byte: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [String] find: [subject]
.nf
    
.fi
.BR.BR.BR

.B  * [String] uppercase
.nf
    
.fi
.BR.BR.BR

.B  * [String] lowercase
.nf
    
.fi
.BR.BR.BR

.B  * [String] last: [subject]
.nf
    
.fi
.BR.BR.BR

.B  * [String] [key]: [value]
.nf
    
.fi
.BR.BR.BR

.B  * [String] replace: [string] with: [other]
.nf
    
.fi
.BR.BR.BR

.B  * [String] pattern: [String] process: [Block] options: [String].
.nf
    
.fi
.BR.BR.BR

.B  * [String] pattern: [String] process: [Block].
.nf
    
.fi
.BR.BR.BR

.B  * [String] contains: [String]
.nf
    
.fi
.BR.BR.BR

.B  * [String] matches: [String].
.nf
    
.fi
.BR.BR.BR

.B  * [String] remove surrounding spaces
.nf
    
.fi
.BR.BR.BR

.B  * [String] number
.nf
    
.fi
.BR.BR.BR

.B  * [String] boolean
.nf
    
.fi
.BR.BR.BR

.B  * [String] split: [String]
.nf
    
.fi
.BR.BR.BR

.B  * [String] characters.
.nf
    
.fi
.BR.BR.BR

.B  * [String] list
.nf
    
.fi
.BR.BR.BR

.B  * [String] append byte: [Number].
.nf
    
.fi
.BR.BR.BR

.B  * [String] compare: [String]
.nf
    
.fi
.BR.BR.BR

.B  * [String] < [String]
.nf
    
.fi
.BR.BR.BR

.B  * [String] ≤ [String]
.nf
    
.fi
.BR.BR.BR

.B  * [String] > [String]
.nf
    
.fi
.BR.BR.BR

.B  * [String] ≥ [String]
.nf
    
.fi
.BR.BR.BR

.BR.BR.BR

.B  * [String] hash: [String]
.nf
    
.fi
.BR.BR.BR

.B  * Block
.nf
    
.fi
.BR.BR.BR

.B  * [Block] apply: [object]
.nf
    
.fi
.BR.BR.BR

.B  * [Block] while: [block]
.nf
    
.fi
.BR.BR.BR

.B  * [Block] run
.nf
    
.fi
.BR.BR.BR

.B  * [Block] set: [name] value: [object]
.nf
    
.fi
.BR.BR.BR

.B  * [Block] error: [object].
.nf
    
.fi
.BR.BR.BR

.B  * [Block] catch: [otherBlock]
.nf
    
.fi
.BR.BR.BR

.B  * [Block] string
.nf
    
.fi
.BR.BR.BR

.B  * [List] new
.nf
    
.fi
.BR.BR.BR

.B  * [List] new
.nf
    
.fi
.BR.BR.BR

.B  * [List] type
.nf
    
.fi
.BR.BR.BR

.B  * [List] append: [Element]
.nf
    
.fi
.BR.BR.BR

.B  * [List] minimum
.nf
    
.fi
.BR.BR.BR

.B  * [List] maximum
.nf
    
.fi
.BR.BR.BR

.B  * [List] map: [Block].
.nf
    
.fi
.BR.BR.BR

.B  * [List] ← [Element1] ; [Element2] ; ...
.nf
    
.fi
.BR.BR.BR

.B  * [List] prepend: [Element].
.nf
    
.fi
.BR.BR.BR

.B  * [List] join: [String].
.nf
    
.fi
.BR.BR.BR

.B  * [List] position: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [List] first.
.nf
    
.fi
.BR.BR.BR

.B  * [List] last.
.nf
    
.fi
.BR.BR.BR

.B  * [List] second last.
.nf
    
.fi
.BR.BR.BR

.B  * [List] put: [Object] at: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [List] pop
.nf
    
.fi
.BR.BR.BR

.B  * [List] - [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [List] shift
.nf
    
.fi
.BR.BR.BR

.B  * [List] count
.nf
    
.fi
.BR.BR.BR

.B  * [List] from: [Begin] length: [End]
.nf
    
.fi
.BR.BR.BR

.B  * [List] replace: [Number] length: [Number] with: [List].
.nf
    
.fi
.BR.BR.BR

.B  * [List] + [List]
.nf
    
.fi
.BR.BR.BR

.B  * [List] by: [List].
.nf
    
.fi
.BR.BR.BR

.B  * [List] copy
.nf
    
.fi
.BR.BR.BR

.BR.BR.BR

.B  * [List] sort: [Block]
.nf
    
.fi
.BR.BR.BR

.B  * [List] string
.nf
    
.fi
.BR.BR.BR

.B  * [List] fill: [Number] with: [Object]
.nf
    
.fi
.BR.BR.BR

.B  * [List] find: [Object].
.nf
    
.fi
.BR.BR.BR

.B  * Map
.nf
    
.fi
.BR.BR.BR

.B  * [Map] type
.nf
    
.fi
.BR.BR.BR

.B  * [Map] put: [Element] at: [Key]
.nf
    
.fi
.BR.BR.BR

.B  * [Map] [Key]: [Value]
.nf
    
.fi
.BR.BR.BR

.B  * [Map] - [String]
.nf
    
.fi
.BR.BR.BR

.B  * [Map] keys
.nf
    
.fi
.BR.BR.BR

.B  * [Map] values
.nf
    
.fi
.BR.BR.BR

.B  * [Map] at: [Key]
.nf
    
.fi
.BR.BR.BR

.B  * [Map] ? [Key]
.nf
    
.fi
.BR.BR.BR

.B  * [Map] count
.nf
    
.fi
.BR.BR.BR

.B  * [Map] each: [Block]
.nf
    
.fi
.BR.BR.BR

.B  * [Map] has: [Object]
.nf
    
.fi
.BR.BR.BR

.B  * [Map] string
.nf
    
.fi
.BR.BR.BR

.B  * File
.nf
    
.fi
.BR.BR.BR

.B  * [File] path
.nf
    
.fi
.BR.BR.BR

.B  * [File] string
.nf
    
.fi
.BR.BR.BR

.B  * [File] read
.nf
    
.fi
.BR.BR.BR

.B  * [File] write: [String]
.nf
    
.fi
.BR.BR.BR

.B  * [File] append: [String]
.nf
    
.fi
.BR.BR.BR

.B  * [File] exists
.nf
    
.fi
.BR.BR.BR

.B  * [File] include
.nf
    
.fi
.BR.BR.BR

.B  * [File] delete
.nf
    
.fi
.BR.BR.BR

.B  * [File] size
.nf
    
.fi
.BR.BR.BR

.B  * [File] open: [string]
.nf
    
.fi
.BR.BR.BR

.B  * [File] close.
.nf
    
.fi
.BR.BR.BR

.B  * [File] read bytes: [Number].
.nf
    
.fi
.BR.BR.BR

.B  * [File] write bytes: [String].
.nf
    
.fi
.BR.BR.BR

.B  * [File] seek: [Number].
.nf
    
.fi
.BR.BR.BR

.B  * [File] rewind.
.nf
    
.fi
.BR.BR.BR

.B  * [File] end.
.nf
    
.fi
.BR.BR.BR

.BR.BR.BR

.B  * [File] unlock.
.nf
    
.fi
.BR.BR.BR

.B  * [File] lock.
.nf
    
.fi
.BR.BR.BR

.B  * [File] list: [String].
.nf
    
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B  * [Program] clean memory
.nf
    
.fi
.BR.BR.BR

.B  * [Program] memory
.nf
    
.fi
.BR.BR.BR

.B  * [Program] memory: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Program] tidiness: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Program] shell: [String]
.nf
    
.fi
.BR.BR.BR

.B  * [Program] argument: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Program] arguments
.nf
    
.fi
.BR.BR.BR

.B  * [Program] end
.nf
    
.fi
.BR.BR.BR

.B  * [Program] setting: [String]
.nf
    
.fi
.BR.BR.BR

.B  * [Program] setting: [Key] value: [Value]
.nf
    
.fi
.BR.BR.BR

.B  * [Program] ask
.nf
    
.fi
.BR.BR.BR

.B  * [Program] input.
.nf
    
.fi
.BR.BR.BR

.B  * [Program] flush.
.nf
    
.fi
.BR.BR.BR

.B  * [Program] error: [String]
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] wait: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] new: [Number]
.nf
    
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B  * [Clock] like: [Clock]
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] zone: [String]
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] zone
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] year: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] month: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] day: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] hour: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] minute: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] second: [Number]
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] year
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] month
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] day
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] hour
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] minute
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] second
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] day of the year
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] weekday
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] time.
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] week
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] format: [String]
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] string
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] number
.nf
    
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B  * [Clock] add: [Number].
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] subtract: [Number].
.nf
    
.fi
.BR.BR.BR

.B  * [Clock] new
.nf
    
.fi
.BR.BR.BR

.B  * [Pen] write: [String]
.nf
    
.fi
.BR.BR.BR

.B  * [Pen] end
.nf
    
.fi
.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.BR.BR.BR

.B  * Request get: [string]
.nf
    
.fi
.BR.BR.BR

.B  * Request getArray: [string].
.nf
    
.fi
.BR.BR.BR

.B  * Request post: [string].
.nf
    
.fi
.BR.BR.BR

.B  * Request postArray: [string].
.nf
    
.fi
.BR.BR.BR

.B  * Request cookie: [string].
.nf
    
.fi
.BR.BR.BR

.B  * Request cookieArray: [string].
.nf
    
.fi
.BR.BR.BR

.B  * Request file: [string].
.nf
    
.fi
.BR.BR.BR

.B  * Request serverOption: [string] is: [string].
.nf
    
.fi
.BR.BR.BR

.B  * Request host: [string] listen: [string] pid: [string] callback: [block].
.nf
    
.fi
.BR.BR.BR

.BR.BR.BR

.B  * [String] escape: '\n'.
.nf
    
.fi
.BR.BR.BR

.B  * [String] unescape: '\n'.
.nf
    
.fi
.BR.BR.BR

.B  * [Json] new
.nf
    
.fi
.BR.BR.BR

.BR.BR.BR

.B  * [Json] parse: [String].
.nf
    
.fi
.BR.BR.BR

.B  * [Json] jsonify: [Map].
.nf
    
.fi
.BR.BR.BR

.B  * C-constructor function.
.nf
    
.fi

.SH BUGS
This is a preliminary version (< 1.0) of Citrine, there might still be very serious bugs.
Please refrain from using this version in a production environment. This version of Citrine
is still considered 'alpha' stage and cannot be expected to be reliable.

.SH AUTHOR
Gabor de Mooij and the Citrine Community
